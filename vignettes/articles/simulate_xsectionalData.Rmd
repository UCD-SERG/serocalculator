---
title: "Generate a simulated cross-sectional sample and estimate seroincidence"
subtitle: "Enteric Fever using HlyE IgG and/or HlyE IgA"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simulate_xsectionalData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


This vignette shows how to simulate a cross-sectional sample of 
seroresponses for incident infections as a Poisson process with frequency `lambda`. 
Responses are generated for the antibodies given in the `antigen_isos` argument.

Age range of the simulated cross-sectional record is `lifespan`.

The size of the sample is `nrep`.

Each individual is simulated separately, but different antibodies are
modelled jointly.

Longitudinal parameters are calculated for an age: `age.fx` (fixed age).
However, when `age.fx` is set to NA then the age at infection is used.

The boolean `renew.params` determines whether each infection uses a
new set of longitudinal parameters, sampled at random from the
posterior predictive output of  the longitudinal model. If set to `FALSE`
a parameter set is chosen at birth and kept, but:
1. the baseline antibody levels (`y0`) are updated with the simulated level
(just) prior to infection, and
2. when `is.na(age.fx)` then the selected parameter sample is updated for the
age when infection occurs.

There is also a variable `n.mc`: when `n.mc==0` then a random MC
sample is chosen out of the posterior set (1:4000). When `n.mc` is
given a value in 1:4000 then the chosen number is fixed and reused
in any subsequent infection. This is for diagnostic purposes.


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```


```{r setup}
library(serocalculator)
library(tidyverse)
library(ggbeeswarm) # for plotting

#load in longitudinal parameters, these are modelled from all SEES cases across all ages and countries 
dmcmc <- getAdditionalData(fileURL = "https://osf.io/download/rtw5k") |> 
  ungroup()

```


## Simulate cross-sectional data
```{r "sim.cs"}
#set seed to reproduce results
set.seed(54321)

# Specify the antibody-isotype responses to simulate
antibodies = c("HlyE_IgA", "HlyE_IgG")

# simulated incidence rate per person-year
lambda <- 0.2;

# range covered in simulations
lifespan <- c(0,20); 

# cross-sectional sample size
nrep <- 100

# biologic noise distribution
dlims <- rbind(c(0.01, 0.5),c(0.01, 0.5))

#generate cross-sectional data
csdata0 <- sim.cs(
  curve_params = dmcmc,
  lambda = lambda,
  n.smpl = nrep,
  age.rng = lifespan,
  antigen_isos = antibodies,
  n.mc = 0,
  renew.params = TRUE,
  add.noise = TRUE,
  noise_limits = dlims
)


```

## Estimate seroincidence

We need to provide noise parameters for the analysis; here, we define them directly in our code:

```{r "noise"}
cond <- data.frame(
  antigen_iso = c("HlyE_IgG", "HlyE_IgA"),
  nu = c(0.5, 0.5),  # Biologic noise (nu)
  eps = c(0.2, 0.2),                             # M noise (eps)
  y.low = c(1, 1),                            # low cutoff (llod)
  y.high = c(5e6, 5e6))                      # high cutoff (y.high)

```

We also need to convert the data to a long format for analysis:

```{r "long-format"}
csdataL <- 
  csdata0 %>% 
  as_tibble() %>%
  pivot_longer(
    cols = c("HlyE_IgG", "HlyE_IgA"), 
    names_to = "antigen_iso", 
    values_to = "value")

```

We can plot the distribution of the antibody responses in the simulated data. 

```{r}


ggplot(csdataL, aes(x=as.factor(antigen_iso), y= value)) +
  geom_beeswarm(size= .2, alpha = .3, aes(color = antigen_iso), show.legend = F) + 
  geom_boxplot(outlier.colour = NA, fill = NA) + 
  scale_y_log10() + 
  theme_linedraw() + 
  labs(x="antigen - isotype")
```

We can estimate incidence with `est.incidence()`:

```{r "est.incidence"}

est1 = est.incidence(
  pop_data = csdataL,
  curve_params = dmcmc,
  noise_params = cond,
  lambda_start = .1,
  build_graph = T,
  verbose = T, # print updates as the function runs
  print_graph = F, # display the log-likelihood curve while `est.incidence()` is running
  antigen_isos = antibodies)

```

We can extract summary statistics with `summary()`:

```{r "summary.est.incidence"}
summary(est1)
```

We can plot the log-likelihood curve with `plot()`:

```{r}
plot(est1)
```

We can set the x-axis to a logarithmic scale, if desired:

```{r}

plot(est1, log_x = TRUE)
```

# Simulate multiple clusters with different lambdas

```{r "init-parallel"}
library(parallel)
library(doParallel)
library(doRNG) # for reproducible results
library(rngtools)
n_cores = max(1, parallel::detectCores() - 1)
# n_cores = 1
print(n_cores)
```

In the preceding code chunk, we have determined that we can use `r n_cores` CPU cores to run computations in parallel.

```{r "do-parallel"}

doParallel::registerDoParallel(cores = n_cores)

#number of clusters 
nclus = 10;

# cross-sectional sample size
nrep <- 100

#incidence rate in e
lmbdaVec <- c(.05,.1, .15, .2, .3)

n_lambda = length(lmbdaVec)

#trying to reproduce results using parallel
rng <- RNGseq(n_lambda * nclus, 1234)

sim.df <- 
  foreach(i = 1:length(lmbdaVec), 
          .combine = bind_rows) %:%
  foreach(n = 1:nclus,  
          r = rng[(i - 1) * nclus + 1:nclus], 
          .combine = bind_rows) %dopar% 
  {
    l = lmbdaVec[i]
    rngtools::setRNG(r)
    sim.cs(
      lambda = l,
      n.smpl = nrep,
      age.rng = lifespan,
      antigen_isos = antibodies,
      n.mc = 0,
      renew.params = TRUE,
      add.noise = TRUE,
      curve_params = dmcmc,
      noise_limits = dlims
    ) %>% 
      mutate(lambda.sim = l, cluster = n) 
  }

print(sim.df)
```

We can plot the distributions of the simulated responses 
```{r}

sim.df.l <- sim.df %>%
  pivot_longer(cols = c("HlyE_IgG", "HlyE_IgA"), values_to = c("value"), names_to = c("antigen_iso"))

ggplot(sim.df.l, aes(x = as.factor(cluster), y= value)) +
  geom_beeswarm(size= .2, alpha = .3, aes(color = antigen_iso)) + 
  geom_boxplot(outlier.colour = NA, fill = NA) + 
  scale_y_log10() + 
  facet_wrap(~antigen_iso + lambda.sim, nrow = 2) + 
  theme_linedraw()

```

## Estimate incidence in each cluster

```{r, "est-by-stratum"}
ests =
  sim.df %>% 
  as_tibble() %>%
  pivot_longer(
    cols = c("HlyE_IgG", "HlyE_IgA"), 
    names_to = "antigen_iso", 
    values_to = "value") %>%
  est.incidence.by(
    curve_params = dmcmc,
    noise_params = cond,
    num_cores = n_cores,
    strata = c("lambda.sim", "cluster"),
    curve_strata_varnames = NULL,
    noise_strata_varnames = NULL,
    verbose = TRUE,
    build_graph = TRUE, # slows down the function substantially
    antigen_isos = c("HlyE_IgG", "HlyE_IgA")
  )

```

`summary(ests)` produces a `tibble()` with some extra meta-data:

```{r}
summary(ests)
```

We can explore the summary table interactively using `DT::datatable()`

```{r}
library(DT)
summary(ests) |> DT::datatable()
```

We can plot the likelihood for a single simulated cluster by subsetting that simulation in `ests` and calling `plot()`:

```{r}
plot(ests[1])
```

We can also plot log-likelihood curves for several clusters at once (your computer might struggle to plot many at once):

```{r "plot-multiple", fig.height = 7}
plot(ests[1:5])
```

The `log_x` argument also works here:

```{r "plot-multiple-log", fig.height = 7}
plot(ests[1:5], log_x = TRUE)
```

### `nlm()` convergence codes

Make sure to check the `nlm()` exit codes (codes 3-5 indicate possible non-convergence):

```{r}
summary(ests) |>
  as_tibble() |> # removes extra meta-data
  select(Stratum, nlm.convergence.code) |> 
  filter(nlm.convergence.code > 2) 
```

Solutions to `nlm()` exit codes 3-5:

* 3: decrease the `stepmin` argument to `est.incidence()`/`est.incidence.by()`
* 4: increase the `iterlim` argument to `est.incidence()`/`est.incidence.by()`
* 5: increase the `stepmax` argument to `est.incidence()`/`est.incidence.by()`

We can extract the indices of problematic strata, if there are any:

```{r}
problem_strata = 
  which(summary(ests)$nlm.convergence.code > 2) |> 
  print()
```

A few clusters had problems; let's take a look:

```{r, fig.height = 7}
plot(ests[problem_strata], log_x = TRUE)
```

Visually, it looks like we approximately reached the MLE, but we should probably re-run those clusters, adjusting the `nlm()` settings appropriately, to be sure.

## plot distribution of estimates by simulated incidence rate

Finally, we can look at our simulation results:

```{r, "graph"}

summary(ests) |> plot(xvar = 'lambda.sim')

```

## extra (remove?)

We can calculate the log-likelihood of the data as a function of the incidence rate, even without running `est.incidence()`.

```{r}

lik_HlyE_IgA = graph.loglik(
  pop_data = csdataL,
  curve_params = 
    dmcmc |> 
    dplyr::mutate(
    alpha = .data$alpha * 365.25,
    d = .data$r - 1),
  noise_params = cond,
  antigen_isos = "HlyE_IgA",
  log_x = TRUE
) |> 
  print()

lik_HlyE_IgG = graph.loglik(
  pop_data = csdataL,
  curve_params = 
    dmcmc |> 
    dplyr::mutate(
    alpha = .data$alpha * 365.25,
    d = .data$r - 1),
  noise_params = cond,
  antigen_isos = "HlyE_IgG",
  log_x = TRUE
) |> 
  print()

lik_both = graph.loglik(
  pop_data = csdataL,
  curve_params = 
    dmcmc |>
    dplyr::mutate(
    alpha = .data$alpha * 365.25,
    d = .data$r - 1),
  noise_params = cond,
  antigen_isos = c("HlyE_IgG", "HlyE_IgA"),
  log_x = TRUE
) |> 
  print()

```
